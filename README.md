# Описание проекта
Яндекс.Билеты В Подарок - это фича в рамках приложения Яндекс.Афиши, позволяющая пользователю создавать индивидуальное поздравление, которое можно отправить вместе с билетом на мероприятие. В рамках второго этапа проекта Яндекс.Мобилизация был реализован клиент Яндекс.Билеты В Подарок под Android.


# Структура документации
Документация поделена на два пункта:
* Вклад. Описание проделанной работы каждым разработчиком.
* Структура приложения. 


# Сущности
## Поздравление
Главной функциональностью нашего приложения является создание поздравлений. Поздравление представленно в программе классом Gift. 

Каждое поздравление привязщывается к конкретному билету. Для этого в классе Gift хранится ссылка на объект типа Ticket. Кроме этого, необходимо было сделать различные типы доступа к билету: для человека, который является получателем подарка, на последнем слайде доступна возможность скачать билет в формате PDF на телефон или поделиться сгенерирьванной ссылкой на просмотр поздравления в соцсетях. Человек, с которым поделились ссылкой на просмотр, на последнем экране будет предложено купить билет на то же мероприятие и пойти на концерт вместе с другом. Для разделения этих сценариев, в классе Gift жранится объект перечисления Type. Он может принимать значения CREATE, RECEIVE_MAIN и RECEIVE_SHARE. 

Поздравление похоже на открытку и состоит из отдельных слайдов с контентом, между которыми можно переключаться. Каждый слайд представлен классом GiftItem; в классе Gift содержится ссылка на список StoryItem'ов. Каждый слайд состоит из одного объекта типа BackgroundItem и списка объектов типа ForegroundItem. 

## BackgroundItem
Интерфейс BackgroundItem реализуется классами:
* Image
* Video
* Color

Color хранит код цвета, который он представляет, а Image и Video -- путь до файлов, которые они представляют. Таким образом, так как поздравление после создания может быть отправлено едиными архивом на сервер, было решено не дублировать на устройстве файлы, содержащиеся в поздравлении. 

## ForegroundItem
Интерфейс ForegroundItem реализуется двумя классами: 
* Text 
* Sticker

Необходимо было сделать добавление на фон любого типа текста и стикеров. И у текста, и у стикеров, необходимо уметь менять положение на экране, угол наклона, размер. При этом, изменения должны применяться мгновенно, без рендеринга и не занимая на устройстве лишнюю память. Вдобавок, стикеры должны появляться с анимацией. И стикеры, и текст, хранят относительное положение на экране по вертикали и горизонтали, а также угол наклона типа float. Текст дополнительно хранит размер шрифта, цвет и ориентацию, а стикер -- размер, scale и идентификатор ресурса. View для текста и стикера создаются прямо перед показом слайда прямо на устройстве. 


# Data слой

## Описание
Data слой приложения состоит из двух частей: работы с локальным хранилищем и работы с сервером.

## Локальное хранилище
* `GiftStorage`. Класс отвечает за работу с данными на устройстве. В локальной базе данных хранятся созданные поздравления, а также вспомогательные флаги для onboarding и empty state. Было решено сосредоточиться на основной функциональности приложения -- создании и просмотре поздравлений. По этой причине, в первой версии приложения доступно создание и редактирование только одного поздравления. Работа с файлами происходит с помощью библиотеки [Paper](https://github.com/pilgr/Paper).
* `MediaStorage`. Класс отвечает за работу с галереей пользователя и шаблонами. Работа с `ContentResolver` происходит с помощью библиотеки [SQL Brite](https://github.com/square/sqlbrite). Шаблоны находятся в папке Assets и для получения доступа к ним копируются в кеш приложения.

## Сервер
* `GiftService`. Класс представляет из себя замоканное общение с сервером. Главные функциональности -- создание ссылок для поздравлений, а также получение поздравлений по ссылкам. В нашей реализации существуют две ссылки: одна для человека, которому доступно скачивание билета из поздравления (тот, кому дарят), второму -- возможность купить билет, к которому привязано поздравление (тот, с кем делятся в соцсетях). Получение поздравления происходит по сгенерированным ранее ссылкам. В дальнейшем можно будет написать реальный сервер, а при генерации ссылки или получении поздравления учитывать дополнительные параметры: токен доступа человека, email и другие. 

## Репозиторий
* `GiftRepository`. Общение презентеров с data слоем ведется через GiftRepository, предоставляющим доступ к GiftService и GiftStorage. Общение презентера с репозиторием ведется в терминах сущностей.


# Покупка
Функционал покупки билета был замокан. Мы сверстали только экраны. Навигация между экранами покупки осуществляется с помощью PurchaseHolderActivity. Данный класс управляет бэкстеком фрагментов и осуществляет переключение между экранами оплаты и покупки. Переключение между экранами происходит с анимацией.


# Купленный билет
`TicketActivity`. На экране билета имеются два состояния: поздравление создано и поздравление не создано. В случае созданного поздравления пользователь может перейти на экран создания. В случае созданного поздравления пользователь может отправить сгенерированную на него ссылку через соцсеть или мессенджер, а также удалить его, перейти на экраны просмотра и редактирования. При попадании на экран после первого создания поздравления, показывается онбординг.


# Конструктор

## Описание
Конструктор составляет главную функциональность приложения. После покупки билета на экране конструктора пользователь может создавать, просматривать и редактировать поздравление. Редактирование состоит из добавления в поздравление различных элементов с разных экранов, их последующего удаления и перемещения. Конструктор состоит из главного экрана и экранов добавления элементов. Так как экраны связаны между собой, было принято решение реализовывать их с помощью фрагментов. При этом, один из фрагментов является главным -- ConstructorFragment, остальные -- второстепенными:
* AddingColorFragment
* MediaPickerFragment
* StickersFragment
* AddingTextFragment

## Навигация
Для соблюдения принципа Single Responsibility, чистоты кода и удобной работы с состояниями фрагментов, была написана ConstructorHolderActivity, в которой инкапсулировано все взаимодействие между фрагментами. Например, при нажатии на кнопку добавления текста внутри ConstructorFragment вызовется метод onOverlayButtonClick с типом накладываемого фрагмента. Далее активити вызывает метод скрытия элементов у ConstructorActivity, а после окончания анимации создается и добавляется в backstack AddingTextFragment. После ввода текста и нажатия кнопки "Добавить" в ConstructorHolderActivity вызовется метод onTextAdded. Активити решает, что нужно скрыть AddingTextFragment и передать полученный текст в ConstructorFragment. 

## Хранение поздравления
В рамках активити, поздравление хранится в виде поля типа Gift в классе ConstructorPresenter, с которым взаимодействует ConstructorFragment. После получения сообщения от ConstructorHolderActivity о добавлении нового элемента, фрагмент сообщает об этом презентеру, который сохраняет изменения в базу данных, а затем сообщает фрагменту о необходимости отобразить изменения. Таким образом, гарантируется, что отображение поздравления всегда соответствует данным, сохраненным в хранилище устройства. 

## ConstructorFragment
Помимо открытия экранов добавления элементов поздравления, одной из главных задач, вставшей перед нами, было создание удобного просмотра поздравления. Было решено использовать два RecyclerView. Один показан во весь экран, так, как поздравление будет видно получателю. Доступен режим воспроизведения, а также переключение между слайдами по свайпу. Второй 
RecyclerView показан снизу, он содержит миниатюры слайдов и предназначен для их удаления, перемещения и удобной навигации (при нажатии на элемент в нижнем списке он отображается в верхнем). Два RecyclerView используют разные адаптеры (PreviewAdapter и ThumbnailsAdapter). Оба адаптера хранят ссылку на объект Gift, содержащийся в презентере. 

Для удобства общения фрагмента и адаптеров, а также атомарности взаимодействия с обоими списками, был создан класс AdapterCoordinatorFacade. Он отвечает за инициализацию и взаимодействие с обоими RecyclerView. Например, при свайпе в верхнем адаптере уведомление об этом получает фасад, затем -- фрагмент. Для установления отображения выбранного элемента в обоих списках фрагмент вызывает метод фасада setSelectedPosition.

## Анимации
Для конструктора требовались анимации кнопок. При развитии приложения их поведение усложнялось.
Для решения этой проблемы был создан ControlsAnimator. Он позволяет разделить все кнопки на группы, задать им позицию, на которую им нужно переместиться, и управлять ими по ключу группы.

## Добавление шаблонов, фото и видео
Для добавления в поздравление шаблонов, фото и видео используется `MediaPickerFragment`. Можно было создать для шаблонов и фото с видео два отдельных фрагмента, но мы решили вместо дублирования кода использовать паттерн State. Фрагмент создается с помощью метода newInstance, в который передается тип -- TEMPLATES или MEDIA. При попытке создания фрагмента без типа выкинется IllegalStateException. В обеих версиях фрагмента снизу находится RecyclerView, в котором можно помечать галочкой файлы, которые хочется добавить к поздравлению. 

### Добавление шаблонов
Некоторые фотографии и видео являются предустановленными в apk. Они хранятся в папке assets и при выборе копируются в кеш приложения. Для остальных частей приложения они неотличимы от файлов, добавленных из галереи.

### Добавление фото и видео
Первые два элемента в RecyclerView отвечают за открытие системной камеры и галереи. А последующие элементы отображают последние фото и видео пользователя. Для получения фото/видео c камеры в локальном хранилище создается файл, с помощью `FileProvider` мы получаем его `Uri` и передаем его в неявный `Intent`. Для открытия системной галереи также кидается неявный `Intent`. В методе `onActivityResult` в приходящем `Intent` проверятся как `Data` так и `ClipData`, так как на разных устройствах по-разному. Для получения последних фото/видео из галере используется `BriteContentResolver` из библиотеки [SQL Brite](https://github.com/square/sqlbrite).

## Добавление цветного фона
Реализовано в пакете adding_color.
Для выбора цвета фона используется ColorPickerAdapter. 

## Добавление стикеров и текста
`AddingTextFragment` и `StickersFragment` отвечают за добавление текста и стикеров соответственно. Для обработки жестов `pan`, `pinch` и `rotate` используется порт [`UIGestureRecognizer`](https://developer.apple.com/documentation/uikit/uigesturerecognizer) из iOS - [`Android UIGestureRecognizer`](https://github.com/sephiroth74/AndroidUIGestureRecognizer). Чтобы сохранить позицию стикера или текста мы переводим абсолютные координаты в проценты с помощью `WindowUtil`. Также мы отслеживаем открытие/закрытие клавиатуры с помощью метода `addOnKeyboardStateListener` в `KeyboardUtils` для того, чтобы клавиатура не закрывала текст.


# Просмотр
Реализован в классе ViewGiftActivity. Для отображения слайдов переиспользуется PreviewAdapter. ViewGiftActivity принимает по время инициализации либо объект класса Gift, либо Uri ссылки на видео на сервере.


# Вклад участников

## Ким Михаил
1. AdapterCoordinator. Принимал участие в проектировании фасада. Это класс, который обобщает работу с двумя RecyclerView. Общая Gift хранится в презентере и все ссылки указывают на нее, которая уведомляет об изменениях фасад. Фасад в свою очередь уведомляет оба адаптера об изменениях.
2. ControlsAnimator. Отвечает за анимацию контролов и подложек в подсказках. Внутри себя подразделяет все контролы на отдельные группы. Хранит внутри себя HashMap<String, ControlsGroup>. Можно показывать или прятать определенные группы контролов. Для конструирования аниматора используется Builder.
3. AnimationCreator. Отвечает за выдачу ValueAnimator'ов. Используется в PreviewAdapter'e и в ControlsAnimator.
4. Верстка последнего экрана с билетом в RecyclerView. Верстка  ConcertListFragment'а.
5. Настроил payload'ы для PreviewAdapter и  ThumbnailsAdapter. Теперь есть отдельные флаги для добавления текста, стикера, отображения и остановки видео, а также флаги для увеличения и уменьшения миниатюр. Это помогает изменять лишь часть вью, а не перезагружать весь слайд или миниатюру полностью 
6. AddingColorFragment. Используется ColorPickerAdapter для выбора цвета фона. При выборе определенного цвета берется позиция элемента в LayoutManager'е и создается круглая ImageView, которая заполняет экран

## Девятилов Дмитрий
### **Разработанные модули**
1. AdapterFacade. В основном модуле приложения - конструкторе, была проблема синхронизации двух RecyclerView между собой и с историей поздравления. Мной было предложено следующее решение: т.к. история общая для всех элементов интерфейса, то все ее изменения были вынесены в класс AdapterCoordinator, который является центром управления двух RecyclerView. В нем хранится и изменяется Объект Gift, общий для обоих адаптеров. В адаптерах происходит только нотификация изменений. Так же связь между двумя адаптерами я организовал через AdapterDelegates, но сделал это очень поздно и данный функционал мы решили не включать.
2. Payloads. Необходимо было делать scale анимацию при выборе элемента, при этом нужно было уменьшить предыдущий элемент и увеличить выбранный. Сначала был написан для этого ItemAnimator, но идеальной работы добиться не получилось, поэтому решили делать все изменения элементов через palyload'ы. Я принимал активное участие в написании этой функциональности.Аналогично, я принимал участие в наложении стикеров и текста на элемент RecyclerView. 
3. Rotation. Мной был написан модуль, отвечающий за поворот элемента. Логика работы следующая: сначала вычисляются координаты двух пальцев, потому находим угол между линиями их соединяющими в полярных координатах, затем переходим обратно в декартовые и устанавливаем rotation для элемента.
4. Delete, Move. Так же мной была написана логика удаления и перемещения элемента внутри нижнего RecyclerView. Это было сделано с помощью кастомного ItemTouchHelper'a.
5. Была написана обертка для ExoPlayer'a, а так же был применен паттерн State, который включал 4 состояния: prepare, play, stop, pause. При состоянии prepare плеер останавливается на предыдущем экране и инициализируется на текущем. При состоянии start плеер начинает проигрывать видео.
6. Паттерн Шаблонный метод помог мне для связывания пяти ViewHolder'ов. В общем методе bind я вызываю 2 абстрактных метода bindView и setDefaultScale, которые по своему переопределены во всех ViewHolder'ах. 
7. Для поворота, перемещения и увелечения текста или стикеров мы написали 3 ItemTouchListener'a: для move, scale и rotate. Мной была написана логика поворота элемента. Для начала нужно найти координаты двух пальцев, затем найти их координаты после перемещения. Затем перевести в полярные координаты прямые, которые соединяют два пальца, найти угол перемещения, как разницу между углами начального и конечного положения. После этого сделать setRotation на View. 
8. Было проделано много работы, связанной с версткой, наложением теней на элементы RecyclerView, скруглением краев и прочее. Так же была написана анимация появления трех кнопок при клике по одной с помощью ValueAnimator.
9. Так же я написал тесты для утилитных классов. 

## Кашин Данил
### Utils
* PathCreator. Создал класс, содержащий один метод, который по имени файла в папке assets приложения копирует его в кеш приложения и возвращает ссылку на него. 

### Data слой: 
#### Пакет Exception.
* Создал два кастомных исключения, обрабатываемых в презентерах в случаях исключительной ситуации.
#### Пакет Local. 
* GiftStorage. Добавил методы для работы с empty state. 
#### Пакет Remote.
* GiftService. Cоздал класс, представляющий из себя замоканный сервис общения с сервером. Cоздал метод создания получения замоканных ссылок на поздравление в случаи возможности скачивания билета и только для просмотра. Создал метод получения замоканного поздравления по ссылкам. Добавил в manifest приложения intent-фильтр для открытия сгенерированных с помощью нашего приложения ссылок. 
* Класс MediaStorage. Добавил метод получения видео для onboarding. Добавил метод получения шаблонов.  

### Presentation слой:
#### Конструктор: 
* PreviewAdapter. Создал и участвовал в дальнейшней разработки адаптера для отображения сохраненного поздравления; разобрался с библиотекой ExoPlayer, научился работать с несколькими Вьюхами для одного объекта SimpleExoPlayer в целях экономии ресурсов; сделал отображение первого кадра видео, который перед просмотром показывается вместо стандартного черного кадра. Этот же адаптер также используется в ViewStoryActivity. Предложил идею добавления текста и стикеров на слайд, при которой для элементов запоминаются координаты относительно экрана и угол поворота, а затем при просмотре View для элементов создаются на лету. Исправил добавление текста (происходило неприятное смещение элемента относительно контейнера). 
* AdaptorCoordinatorFacade. Предложил идею создания координатора для адаптеров и создал соответствующий класс. В классе ConstructorFragment работа с адаптптами идет через координатор, это позволяет синхронизировать адаптеры без создания между ними жесткой зависимости. 
* ConstructorHolderActivity. Создал класс, отвечающий за взаимодействие фрагмента, в котором происходит непосредственная работа с поздравление, и фрагментов, накладываемых поверх него (для добавления текста, стикеров, выбор фона...).
* ConstructorFragment. Добавил onboarding (проигрывание видео при первом открытии конструктора). Добавил два empty state: первый показывается, когда поздравление не содержит слайдов (предложение добавить фон); второй -- при первом добавлении фона (предложение добавить текст или стикеры).
* MediaPickerFragment. Расширил функциональность, добавив выбор предустановленных шаблонов и вложенный класс State, в котором хранится тип фрагмента -- шаблоны или локальное хранилище. Создание фрагмента осуществляется статическим методом MediaPickerFragment newInstance(State.Type type)

#### Билет
* TicketActivity. Создал экран билета, с которого можно делиться поздравлением, удалить его, а также перейти на экраны редактирования и просмотра. Принимал участие в создании анимации выбора действия с поздравлением. Добавил empty state, появляющийся при открытии экрана после создания поздравления в первый раз. Полностью прописал логику создания, сохранения и отображения напоминаний об отправке поздравления, однако, в релизный билд данная функциональность не вошла. 

#### Просмотр
* ViewGiftActivity. Создал активити для просмотра поздравления. Она открывается как во время просмотра созданного поздравления, так и при клике на сгенерированную ссылку при получении. Открытие ссылки происходит с помощью intent-фильтра. Обрабатываются случаи просмотра при создании, получении с возможностью скачать билет и получении билета после шаринга получателям в соцсетях. Получатель и человек, с которым поделились поздравлением, могут на последнем слайде расшарить поздравление в соцсетях. 

#### Покупка
* PurchaseHolderActivity. Создал активити для работы с бекстеком фрагментов при покупке билета. 


# Пестряков Максим
- `MediaPickerFragment` - выбор фоток из галереи + фото и системная галерея
- `StickersFragment` - добавление стикеров + жесты (move, pinch-to-zoom, rotation)
- `AddingTextFragment` - добавление текста
- `BottomNavigationActivity` - активити покупки билета

